// pkg/vdbe/integration_test.go
package vdbe

import (
	"path/filepath"
	"testing"

	"tur/pkg/btree"
	"tur/pkg/pager"
	"tur/pkg/record"
	"tur/pkg/schema"
	"tur/pkg/sql/parser"
	"tur/pkg/types"
)

// TestVDBEEndToEnd tests the complete flow: SQL -> AST -> VDBE bytecode -> execution
func TestVDBEEndToEnd(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "test.db")

	p, err := pager.Open(path, pager.Options{PageSize: 4096})
	if err != nil {
		t.Fatalf("failed to open pager: %v", err)
	}
	defer p.Close()

	// Create table storage
	bt, _ := btree.Create(p)

	// Set up catalog
	catalog := schema.NewCatalog()
	catalog.CreateTable(&schema.TableDef{
		Name: "products",
		Columns: []schema.ColumnDef{
			{Name: "id", Type: types.TypeInt, PrimaryKey: true},
			{Name: "name", Type: types.TypeText},
			{Name: "price", Type: types.TypeInt},
		},
		RootPage: bt.RootPage(),
	})

	// Insert test data via VDBE
	insertTests := []string{
		"INSERT INTO products (id, name, price) VALUES (1, 'Apple', 100)",
		"INSERT INTO products (id, name, price) VALUES (2, 'Banana', 50)",
		"INSERT INTO products (id, name, price) VALUES (3, 'Cherry', 200)",
	}

	for _, sql := range insertTests {
		stmt, err := parser.New(sql).Parse()
		if err != nil {
			t.Fatalf("parse failed for '%s': %v", sql, err)
		}

		compiler := NewCompiler(catalog, p)
		prog, err := compiler.Compile(stmt)
		if err != nil {
			t.Fatalf("compile failed for '%s': %v", sql, err)
		}

		vm := NewVM(prog, p)
		vm.SetNumRegisters(compiler.NumRegisters())

		if err := vm.Run(); err != nil {
			t.Fatalf("run failed for '%s': %v", sql, err)
		}
	}

	// Query the data back
	selectTests := []struct {
		sql      string
		expected int // number of rows expected
	}{
		{"SELECT id, name, price FROM products", 3},
		{"SELECT * FROM products", 3},
		{"SELECT name FROM products WHERE price > 75", 2}, // Apple and Cherry
		{"SELECT id FROM products WHERE price = 50", 1},   // Banana
	}

	for _, tt := range selectTests {
		t.Run(tt.sql, func(t *testing.T) {
			stmt, err := parser.New(tt.sql).Parse()
			if err != nil {
				t.Fatalf("parse failed: %v", err)
			}

			compiler := NewCompiler(catalog, p)
			prog, err := compiler.Compile(stmt)
			if err != nil {
				t.Fatalf("compile failed: %v", err)
			}

			vm := NewVM(prog, p)
			vm.SetNumRegisters(compiler.NumRegisters())

			if err := vm.Run(); err != nil {
				t.Fatalf("run failed: %v", err)
			}

			results := vm.Results()
			if len(results) != tt.expected {
				t.Errorf("expected %d rows, got %d", tt.expected, len(results))
				for i, row := range results {
					t.Logf("  row %d: %v", i, row)
				}
			}
		})
	}
}

// TestVDBEBytecodeInspection tests that we can inspect generated bytecode
func TestVDBEBytecodeInspection(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "test.db")

	p, _ := pager.Open(path, pager.Options{PageSize: 4096})
	defer p.Close()

	bt, _ := btree.Create(p)

	catalog := schema.NewCatalog()
	catalog.CreateTable(&schema.TableDef{
		Name:     "test",
		Columns:  []schema.ColumnDef{{Name: "x", Type: types.TypeInt}},
		RootPage: bt.RootPage(),
	})

	stmt, _ := parser.New("SELECT x FROM test").Parse()

	compiler := NewCompiler(catalog, p)
	prog, _ := compiler.Compile(stmt)

	// Verify bytecode structure
	if prog.Len() < 5 {
		t.Errorf("expected at least 5 instructions, got %d", prog.Len())
	}

	// First instruction should be Init
	first := prog.Get(0)
	if first.Op != OpInit {
		t.Errorf("expected first instruction to be Init, got %s", first.Op)
	}

	// Last instruction should be Halt
	last := prog.Get(prog.Len() - 1)
	if last.Op != OpHalt {
		t.Errorf("expected last instruction to be Halt, got %s", last.Op)
	}

	// Print bytecode for debugging
	t.Log("Generated bytecode:")
	for i := 0; i < prog.Len(); i++ {
		instr := prog.Get(i)
		t.Logf("  %3d: %-12s P1=%d P2=%d P3=%d P4=%v",
			i, instr.Op, instr.P1, instr.P2, instr.P3, instr.P4)
	}
}

// TestVDBEComplexQuery tests a more complex query with multiple conditions
func TestVDBEComplexQuery(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "test.db")

	p, _ := pager.Open(path, pager.Options{PageSize: 4096})
	defer p.Close()

	bt, _ := btree.Create(p)

	// Insert data directly
	for i := 1; i <= 10; i++ {
		key := make([]byte, 8)
		key[7] = byte(i)
		values := []types.Value{
			types.NewInt(int64(i)),
			types.NewInt(int64(i * 10)),
		}
		bt.Insert(key, record.Encode(values))
	}

	catalog := schema.NewCatalog()
	catalog.CreateTable(&schema.TableDef{
		Name: "numbers",
		Columns: []schema.ColumnDef{
			{Name: "n", Type: types.TypeInt},
			{Name: "n10", Type: types.TypeInt},
		},
		RootPage: bt.RootPage(),
	})

	// Query: SELECT n FROM numbers WHERE n > 3 AND n < 8
	// Should return: 4, 5, 6, 7
	sql := "SELECT n FROM numbers WHERE n > 3"
	stmt, err := parser.New(sql).Parse()
	if err != nil {
		t.Fatalf("parse failed: %v", err)
	}

	compiler := NewCompiler(catalog, p)
	prog, err := compiler.Compile(stmt)
	if err != nil {
		t.Fatalf("compile failed: %v", err)
	}

	vm := NewVM(prog, p)
	vm.SetNumRegisters(compiler.NumRegisters())

	if err := vm.Run(); err != nil {
		t.Fatalf("run failed: %v", err)
	}

	results := vm.Results()
	if len(results) != 7 { // 4,5,6,7,8,9,10
		t.Errorf("expected 7 rows, got %d", len(results))
	}

	// Verify the values
	for i, row := range results {
		expected := int64(i + 4)
		if row[0].Int() != expected {
			t.Errorf("row %d: expected %d, got %d", i, expected, row[0].Int())
		}
	}
}

// TestVDBEExpressionEvaluation tests expression evaluation in SELECT
func TestVDBEExpressionEvaluation(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "test.db")

	p, _ := pager.Open(path, pager.Options{PageSize: 4096})
	defer p.Close()

	bt, _ := btree.Create(p)

	// Insert a row with id=10, value=5
	key := make([]byte, 8)
	key[7] = 1
	values := []types.Value{types.NewInt(10), types.NewInt(5)}
	bt.Insert(key, record.Encode(values))

	catalog := schema.NewCatalog()
	catalog.CreateTable(&schema.TableDef{
		Name: "calc",
		Columns: []schema.ColumnDef{
			{Name: "a", Type: types.TypeInt},
			{Name: "b", Type: types.TypeInt},
		},
		RootPage: bt.RootPage(),
	})

	// Query: SELECT a, b FROM calc WHERE a > b
	sql := "SELECT a, b FROM calc WHERE a > b"
	stmt, _ := parser.New(sql).Parse()

	compiler := NewCompiler(catalog, p)
	prog, _ := compiler.Compile(stmt)

	vm := NewVM(prog, p)
	vm.SetNumRegisters(compiler.NumRegisters())
	vm.Run()

	results := vm.Results()
	if len(results) != 1 {
		t.Fatalf("expected 1 row, got %d", len(results))
	}

	if results[0][0].Int() != 10 || results[0][1].Int() != 5 {
		t.Errorf("expected (10, 5), got (%d, %d)", results[0][0].Int(), results[0][1].Int())
	}
}

// TestVDBEDeleteCompilation tests compiling DELETE to VDBE bytecode
func TestVDBEDeleteCompilation(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "test.db")

	p, err := pager.Open(path, pager.Options{PageSize: 4096})
	if err != nil {
		t.Fatalf("failed to open pager: %v", err)
	}
	defer p.Close()

	// Create table and insert data
	bt, _ := btree.Create(p)

	catalog := schema.NewCatalog()
	catalog.CreateTable(&schema.TableDef{
		Name: "items",
		Columns: []schema.ColumnDef{
			{Name: "id", Type: types.TypeInt, PrimaryKey: true},
			{Name: "name", Type: types.TypeText},
		},
		RootPage: bt.RootPage(),
	})

	// Insert test data via VDBE
	insertSQL := []string{
		"INSERT INTO items (id, name) VALUES (1, 'Apple')",
		"INSERT INTO items (id, name) VALUES (2, 'Banana')",
		"INSERT INTO items (id, name) VALUES (3, 'Cherry')",
	}

	for _, sql := range insertSQL {
		stmt, _ := parser.New(sql).Parse()
		compiler := NewCompiler(catalog, p)
		prog, _ := compiler.Compile(stmt)
		vm := NewVM(prog, p)
		vm.SetNumRegisters(compiler.NumRegisters())
		if err := vm.Run(); err != nil {
			t.Fatalf("insert failed: %v", err)
		}
	}

	// Verify initial count is 3
	selectStmt, _ := parser.New("SELECT id FROM items").Parse()
	selectCompiler := NewCompiler(catalog, p)
	selectProg, _ := selectCompiler.Compile(selectStmt)
	selectVM := NewVM(selectProg, p)
	selectVM.SetNumRegisters(selectCompiler.NumRegisters())
	selectVM.Run()
	if len(selectVM.Results()) != 3 {
		t.Fatalf("expected 3 rows before delete, got %d", len(selectVM.Results()))
	}

	// Compile and execute DELETE with WHERE clause
	deleteSQL := "DELETE FROM items WHERE id = 2"
	deleteStmt, err := parser.New(deleteSQL).Parse()
	if err != nil {
		t.Fatalf("parse delete failed: %v", err)
	}

	deleteCompiler := NewCompiler(catalog, p)
	deleteProg, err := deleteCompiler.Compile(deleteStmt)
	if err != nil {
		t.Fatalf("compile delete failed: %v", err)
	}

	deleteVM := NewVM(deleteProg, p)
	deleteVM.SetNumRegisters(deleteCompiler.NumRegisters())
	if err := deleteVM.Run(); err != nil {
		t.Fatalf("delete execution failed: %v", err)
	}

	// Verify count is now 2
	selectCompiler2 := NewCompiler(catalog, p)
	selectProg2, _ := selectCompiler2.Compile(selectStmt)
	selectVM2 := NewVM(selectProg2, p)
	selectVM2.SetNumRegisters(selectCompiler2.NumRegisters())
	selectVM2.Run()
	if len(selectVM2.Results()) != 2 {
		t.Errorf("expected 2 rows after delete, got %d", len(selectVM2.Results()))
	}

	// Verify id=2 is gone
	for _, row := range selectVM2.Results() {
		if row[0].Int() == 2 {
			t.Error("id=2 should have been deleted")
		}
	}
}

// TestVDBEDeleteAll tests DELETE without WHERE clause (delete all rows)
func TestVDBEDeleteAll(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "test.db")

	p, _ := pager.Open(path, pager.Options{PageSize: 4096})
	defer p.Close()

	bt, _ := btree.Create(p)

	catalog := schema.NewCatalog()
	catalog.CreateTable(&schema.TableDef{
		Name: "temp",
		Columns: []schema.ColumnDef{
			{Name: "id", Type: types.TypeInt, PrimaryKey: true},
		},
		RootPage: bt.RootPage(),
	})

	// Insert data
	for i := 1; i <= 5; i++ {
		sql := "INSERT INTO temp (id) VALUES (" + string(rune('0'+i)) + ")"
		// Use proper formatting
		insertSQL := "INSERT INTO temp (id) VALUES (" + intToStr(i) + ")"
		stmt, _ := parser.New(insertSQL).Parse()
		compiler := NewCompiler(catalog, p)
		prog, _ := compiler.Compile(stmt)
		vm := NewVM(prog, p)
		vm.SetNumRegisters(compiler.NumRegisters())
		_ = sql // suppress unused warning
		vm.Run()
	}

	// Delete all rows
	deleteSQL := "DELETE FROM temp"
	deleteStmt, _ := parser.New(deleteSQL).Parse()
	deleteCompiler := NewCompiler(catalog, p)
	deleteProg, err := deleteCompiler.Compile(deleteStmt)
	if err != nil {
		t.Fatalf("compile delete failed: %v", err)
	}

	deleteVM := NewVM(deleteProg, p)
	deleteVM.SetNumRegisters(deleteCompiler.NumRegisters())
	if err := deleteVM.Run(); err != nil {
		t.Fatalf("delete execution failed: %v", err)
	}

	// Verify table is empty
	selectStmt, _ := parser.New("SELECT id FROM temp").Parse()
	selectCompiler := NewCompiler(catalog, p)
	selectProg, _ := selectCompiler.Compile(selectStmt)
	selectVM := NewVM(selectProg, p)
	selectVM.SetNumRegisters(selectCompiler.NumRegisters())
	selectVM.Run()
	if len(selectVM.Results()) != 0 {
		t.Errorf("expected 0 rows after delete all, got %d", len(selectVM.Results()))
	}
}

// intToStr converts int to string (simple helper)
func intToStr(n int) string {
	if n == 0 {
		return "0"
	}
	result := ""
	for n > 0 {
		result = string(rune('0'+n%10)) + result
		n /= 10
	}
	return result
}
